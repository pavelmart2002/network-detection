# Документация по работе программы захвата пакетов

## Общее описание
Программа предназначена для захвата и анализа сетевых пакетов, с особым фокусом на обнаружение деаутентификационных атак в беспроводных сетях.

## Структура программы

### 1. Импорты и зависимости
```python
from scapy.all import sniff, Packet, IP, conf, Dot11, Dot11Beacon  # Основная библиотека для работы с пакетами
from datetime import datetime  # Для временных меток
from typing import Callable, Optional, Dict, List  # Типизация
import threading  # Для многопоточности
import time  # Для задержек
import os  # Для работы с файловой системой
import logging  # Для логирования
from logging.handlers import RotatingFileHandler  # Для ротации логов
from packet_analyzer import PacketAnalyzer  # Наш анализатор пакетов
import ctypes  # Для проверки прав администратора
from subprocess import run, PIPE  # Для выполнения системных команд
from scapy.arch.windows import get_windows_if_list  # Для получения списка интерфейсов Windows
import sys  # Для системных операций
```

### 2. Настройка логирования
```python
log_dir = "logs"  # Директория для логов
if not os.path.exists(log_dir):
    os.makedirs(log_dir)  # Создаем директорию, если её нет

logging.basicConfig(
    level=logging.DEBUG,  # Максимально подробное логирование
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(log_dir, 'packet_capture.log')),  # Запись в файл
        logging.StreamHandler()  # Вывод в консоль
    ]
)
```

### 3. Функция проверки прав администратора
```python
def is_admin():
    """
    Проверяет, запущена ли программа с правами администратора
    Returns:
        bool: True если есть права администратора
    """
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False
```

### 4. Класс NetworkInterface
```python
class NetworkInterface:
    """
    Хранит информацию о сетевом интерфейсе
    Attributes:
        name (str): Имя интерфейса (обычно индекс)
        description (str): Описание интерфейса
        guid (str): GUID интерфейса в Windows
    """
    def __init__(self, name, description, guid):
        self.name = name
        self.description = description
        self.guid = guid
```

### 5. Основной класс PacketCapture

#### 5.1 Инициализация
```python
def __init__(self):
    """
    Инициализирует объект захвата пакетов
    Проверяет:
    - Права администратора
    - Наличие Npcap
    Устанавливает:
    - Флаги состояния
    - Потоки
    - Колбэки
    - Параметры захвата
    """
```

#### 5.2 Получение интерфейсов
```python
def _get_interfaces(self):
    """
    Находит все беспроводные интерфейсы
    Процесс:
    1. Получает список всех интерфейсов через Scapy
    2. Фильтрует беспроводные по ключевым словам
    3. Тестирует каждый интерфейс на возможность захвата
    4. Создает объекты NetworkInterface для рабочих интерфейсов
    """
```

#### 5.3 Проверка деаутентификационных пакетов
```python
def _is_deauth_packet(self, packet):
    """
    Анализирует пакет на признаки деаутентификации
    Проверяет:
    1. Наличие слоя Dot11
    2. Тип пакета (0 - Management)
    3. Подтип пакета:
       - 10: Deauthentication
       - 12: Disassociation
    """
```

#### 5.4 Обработка пакетов
```python
def _process_packet(self, packet):
    """
    Обрабатывает каждый захваченный пакет
    Процесс:
    1. Проверяет, является ли пакет деаутентификационным
    2. Если да - вызывает callback функцию
    """
```

#### 5.5 Основной захват
```python
def _capture_packets(self):
    """
    Основной цикл захвата пакетов
    Процесс:
    1. Проверяет наличие интерфейсов
    2. Для каждого интерфейса:
       - Пытается начать захват
       - Если успешно - продолжает захват
       - Если нет - пробует следующий
    3. Использует sniff() из Scapy с параметрами:
       - iface: индекс интерфейса
       - prn: функция обработки пакетов
       - store: 0 (не хранить пакеты)
       - monitor: True (режим мониторинга)
    """
```

#### 5.6 Переключение каналов
```python
def _switch_channel_netsh(self, iface_name, channel, adapter_guid=None, reg_path=None):
    """
    Переключает канал Wi-Fi через netsh
    Процесс:
    1. Формирует разные варианты имени интерфейса
    2. Пробует команду netsh для каждого варианта
    3. Проверяет успешность выполнения
    """
```

#### 5.7 Управление захватом
```python
def start_capture(self, packet_callback, mac_callback=None, error_callback=None):
    """
    Запускает захват пакетов
    Процесс:
    1. Проверяет, не запущен ли уже захват
    2. Устанавливает колбэки
    3. Получает список интерфейсов
    4. Запускает поток захвата
    """

def stop_capture(self):
    """
    Останавливает захват пакетов
    Процесс:
    1. Устанавливает флаг остановки
    2. Ждет завершения потоков
    3. Проверяет корректность остановки
    """
```

## Обнаружение атак

### 1. Deauthentication Attack
```python
def _is_deauth_packet(self, packet):
    """
    Проверяет пакеты на тип 0 (Management) и подтипы:
    - 10: Deauthentication
    - 12: Disassociation
    """
```

### 2. Beacon Flood Attack
```python
def _is_beacon_flood(self, packet):
    """
    Обнаруживает Beacon Flood атаки по следующим признакам:
    - Аномально высокая частота Beacon фреймов (>50/сек)
    - Отслеживание по MAC-адресу источника
    - Анализ в временном окне 1 секунда
    - Сброс счетчиков каждые 5 секунд
    """
```

### 3. Request Flood Attack
```python
def _is_request_flood(self, packet):
    """
    Обнаруживает Request Flood атаки по следующим признакам:
    - Аномально высокая частота Probe Request (>100/сек)
    - Отслеживание по MAC-адресу источника
    - Анализ в временном окне 1 секунда
    - Сброс счетчиков каждые 5 секунд
    """
```

### Параметры обнаружения

1. Beacon Flood:
   - Порог: 50 beacon'ов в секунду
   - Временное окно: 1 секунда
   - Период сброса: 5 секунд

2. Request Flood:
   - Порог: 100 запросов в секунду
   - Временное окно: 1 секунда
   - Период сброса: 5 секунд

3. Deauthentication:
   - Тип фрейма: Management (0)
   - Подтипы: Deauthentication (10), Disassociation (12)

### Структура данных для отслеживания

```python
self.mac_data = {
    'MAC_ADDRESS': {
        'beacon_count': 0,     # Счетчик Beacon фреймов
        'request_count': 0,    # Счетчик Request фреймов
        'first_seen': time,    # Время первого пакета
        'last_seen': time      # Время последнего пакета
    }
}
```

### Обработка обнаруженных атак

При обнаружении атаки:
1. Логируется предупреждение с деталями:
   - Тип атаки
   - MAC-адрес источника
   - Частота пакетов
2. К пакету добавляется атрибут attack_type
3. Вызывается callback-функция с пакетом

### Пример вывода логов

```
WARNING - Possible Beacon Flood attack detected from 00:11:22:33:44:55
WARNING - Beacon rate: 75.32 beacons/sec

WARNING - Possible Request Flood attack detected from AA:BB:CC:DD:EE:FF
WARNING - Request rate: 152.67 requests/sec

INFO - Deauth packet detected from 11:22:33:44:55:66 to FF:FF:FF:FF:FF:FF
```

## Использование программы

### 1. Требования
- Windows
- Python 3.x
- Npcap (установленный с опцией WinPcap API-compatible Mode)
- Права администратора

### 2. Запуск
```python
capture = PacketCapture()
capture.start_capture(
    packet_callback=lambda p: print(f"Packet: {p.summary()}"),
    error_callback=lambda e: print(f"Error: {e}")
)
```

### 3. Обработка ошибок
Программа логирует все действия и ошибки в:
- Консоль
- Файл logs/packet_capture.log

### 4. Остановка
```python
capture.stop_capture()
```

## Возможные проблемы и решения

1. "No working interfaces found":
   - Проверьте установку Npcap
   - Убедитесь, что Wi-Fi адаптер включен
   - Запустите от имени администратора

2. "Failed to capture on interface":
   - Проверьте поддержку режима мониторинга
   - Попробуйте переустановить драйверы

3. "Permission Error":
   - Запустите программу от имени администратора

4. "Npcap not installed":
   - Установите Npcap с сайта https://npcap.com/
   - Включите опцию WinPcap API-compatible Mode при установке

## Установка в Linux

1. Скопируйте все файлы программы на USB-накопитель:
   - main.py
   - packet_capture.py
   - packet_analyzer.py
   - setup_linux.sh
   - DOCUMENTATION.md

2. На компьютере с Linux:
   - Создайте новую папку для программы:
     ```bash
     mkdir ~/network-detection
     ```
   
   - Скопируйте все файлы в эту папку
   
   - Сделайте скрипт установки исполняемым:
     ```bash
     chmod +x setup_linux.sh
     ```
   
   - Запустите скрипт установки:
     ```bash
     sudo ./setup_linux.sh
     ```

3. После установки запустите программу командой:
   ```bash
   sudo network-detection
   ```

## Требования для Linux
- Ubuntu/Debian Linux
- Python 3.8 или выше
- Права root для захвата сетевых пакетов
- Беспроводной адаптер с поддержкой режима мониторинга

## Возможные проблемы в Linux

1. Если беспроводной адаптер не переходит в режим мониторинга:
   ```bash
   sudo ip link set <interface> down
   sudo iwconfig <interface> mode monitor
   sudo ip link set <interface> up
   ```
   Замените <interface> на имя вашего WiFi интерфейса (например, wlan0)

2. Если программа не запускается из-за ошибок с правами доступа:
   ```bash
   sudo chown -R root:root /opt/network-detection
   sudo chmod -R 755 /opt/network-detection
   ```

## Типы обнаруживаемых атак

### 1. Deauthentication Attack (Атака деаутентификации)

#### Описание
Злоумышленник отправляет поддельные фреймы деаутентификации, заставляя клиентов отключаться от точки доступа.

#### Механизм атаки
1. Атакующий отслеживает активные соединения в сети
2. Генерирует фреймы деаутентификации, подделывая MAC-адрес точки доступа
3. Отправляет эти фреймы клиентам, вызывая их отключение

#### Признаки атаки
- Большое количество фреймов деаутентификации
- Фреймы типа Management (0) с подтипом 10
- Фреймы разассоциации (подтип 12)

#### Последствия
- Отключение клиентов от сети
- Прерывание сетевых соединений
- Невозможность использования сети

### 2. Beacon Flood Attack (Атака переполнения маяками)

#### Описание
Атакующий отправляет множество поддельных Beacon фреймов, имитируя большое количество точек доступа.

#### Механизм атаки
1. Генерация множества поддельных SSID
2. Массовая рассылка Beacon фреймов с разными SSID
3. Создание помех для легитимных точек доступа

#### Признаки атаки
- Аномально высокая частота Beacon фреймов (>50/сек)
- Множество разных SSID от одного источника
- Постоянный поток Beacon фреймов

#### Последствия
- Замедление работы клиентских устройств
- Сложности при поиске легитимных сетей
- Повышенное энергопотребление клиентских устройств

### 3. Request Flood Attack (Атака переполнения запросами)

#### Описание
Массовая отправка Probe Request фреймов для создания нагрузки на сеть и точки доступа.

#### Механизм атаки
1. Генерация большого количества Probe Request фреймов
2. Использование разных MAC-адресов источника
3. Постоянная отправка запросов в сеть

#### Признаки атаки
- Высокая частота Probe Request (>100/сек)
- Запросы могут идти с разных MAC-адресов
- Постоянный поток запросов

#### Последствия
- Повышенная нагрузка на точки доступа
- Замедление обработки легитимных запросов
- Возможные сбои в работе точек доступа

### Методы защиты

1. **От Deauthentication Attack:**
   - Использование WPA3
   - Включение Management Frame Protection
   - Фильтрация по MAC-адресам

2. **От Beacon Flood:**
   - Использование белых списков SSID
   - Игнорирование слабых сигналов
   - Кэширование легитимных точек доступа

3. **От Request Flood:**
   - Ограничение частоты обработки запросов
   - Временная блокировка подозрительных MAC-адресов
   - Приоритизация известных клиентов

### Настройка обнаружения

Для каждого типа атаки можно настроить пороги срабатывания:

```python
# Пороги для Beacon Flood
BEACON_FLOOD_THRESHOLD = 50  # пакетов в секунду
BEACON_FLOOD_WINDOW = 5      # секунд для анализа

# Пороги для Request Flood
REQUEST_FLOOD_THRESHOLD = 100  # пакетов в секунду
REQUEST_FLOOD_WINDOW = 5       # секунд для анализа

# Настройки для Deauth
DEAUTH_TRACKING_WINDOW = 10    # секунд для отслеживания
DEAUTH_THRESHOLD = 20          # пакетов в окне
```

### Рекомендации по настройке

1. **Beacon Flood:**
   - В нормальной сети точка доступа отправляет 10-20 beacon'ов в секунду
   - Порог 50+ обычно указывает на атаку
   - Можно снизить до 30-40 для более ранней детекции

2. **Request Flood:**
   - Нормальное устройство отправляет 1-5 запросов в секунду
   - Порог 100+ надежно выявляет атаку
   - Можно настроить от 50 до 150 в зависимости от сети

3. **Deauthentication:**
   - Легитимные деаутентификации происходят редко
   - Любое значительное количество таких пакетов подозрительно
   - Рекомендуется отслеживать паттерны повторения
